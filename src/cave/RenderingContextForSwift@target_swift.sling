
/*
 * This file is part of Jkop
 * Copyright (c) 2016-2018 Job and Esther Technologies Oy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class is RenderingContext:

func forContext(context as GuiApplicationContext) static as this
{
	assert ctx
	var v = new this()
	v.setCtx(ctx)
	return v
}

prop ctx as GuiApplicationContext
var rectangle as !"CGRect"
var fontDescription as FontDescription
var textAlign = RenderingContext.ALIGN_LEFT
var lineWidth = 5
var strokeColor as Color
var fillColor as Color
var textBaseline as int

func setFillStyle(style as object) override
{
	var f as Color
	if style is string {
		f = Color.instance(style as! string)
	}
	else if style is Color {
		f = style as! Color
	}
	if f {
		fillColor = f.toARGBInt32()
	}
}

func setStrokeStyle(style as object) override
{
	var f as Color
	if style is string {
		f = Color.instance(style as! string)
	}
	else if style is Color {
		f = style as! Color
	}
	if f {
		strokeColor = f.toARGBInt32()
	}
}

func setShadowColor(color as Color) stub override
func setShadowBlur(blur as double) stub override
func setShadowOffsetX(offset as double) stub override
func setShadowOffsetY(offset as double) stub override
func createLinearGradient(x0 as double, y0 as double, x1 as double, y1 as double) stub override as object
func createPattern(image as Image, repeat as int) override as object

func createRadialGradient(x0 as double, y0 as double, r0 as double, x1 as double, y1 as double, r1 as double) override as object
{
	var centerX = x0 + r0 as float
	var centerY = y0 + r0 as float
	var radius0 = r0 as float
	var radius1 = r1 as float
	lang "swift" {{{
		var gradient = NSGradient(Color.black, Color.white())
		gradient.draw(centerX, radius0, centerY, radius1, drawsAfterEndingLocation: NSGradient.DrawingOptions)
	}}}
}

func addColorStop(gradient as object, index as double, color as Color) stub override

func setLineCap(cap as int) override
{
	var c as int
	lang "swift" {{{
		if cap == RenderingContext.LINE_CAP_BUTT {
			c = CGLineCap.butt
		}
		if cap == RenderingContext.LINE_CAP_ROUND {
			c = CGLineCap.round
		}
		if cap == RenderingContext.LINE_CAP_SQUARE {
			c = CGLineCap.square
		}
		self.ctx.setLineCap(c)
	}}}
}

func setLineJoin(join as int) override
{
	var jn as int
	lang "swift" {{{
		if join == RenderingContext.LINE_JOIN_MITER {
			jn = CGLineJoin.miter
		}
		if join == RenderingContext.LINE_JOIN_BEVEL {
			jn = CGLineJoin.bevel
		}
		if join == RenderingContext.LINE_JOIN_ROUND {
			jn = CGLineJoin.round
		}
		self.ctx.setLineJoin(jn)
	}}}
}

func setLineWidth(width as double) override
{
	lineWidth = width as float
	lang "swift" {{{
		self.ctx.setLineWidth(lineWidth)
	}}}
}

func setMiterLimit(limit as double) override
{
	lang "swift" {{{
		self.ctx.setMiterLimit(limit as float)
	}}}
}

func rect(x as double, y as double, width as double, height as double) override
{
	var xx = x as int
	var yy = y as int
	var ww = xx + width as int
	var hh = yy + height as int
	lang "swift" {{{
		rectangle = CGRect(x: xx, y: yy, width: ww, height: hh)
	}}}
}

func fillRect(x as double, y as double, width as double, height as double) override
{
	var xx = x as float
	var yy = y as float
	var ww = xx + width as float
	var hh = yy + height as float
	lang "swift" {{{
		self.ctx.fill(CGRect(x: xx, y: yy, width: ww, height: hh))
	}}}
}

func strokeRect(x as double, y as double, width as double, height as double) override
{
	var xx = x as float
	var yy = y as float
	var ww = xx + width as float
	var hh = yy + height as float
	lang "swift" {{{
		self.ctx.stroke(CGRect(x: xx, y: yy, width: ww, height: hh))
	}}}
}

func clearRect(x as double, y as double, width as double, height as double) override
{
	lang "swift" {{{
		self.ctx.clearRect(CGRect(x: x, y: y, width: width, height: height))
	}}}
}

func fill override
{
	lang "swift" {{{
		self.ctx.fill()
	}}}
	
}

func stroke override
{
	lang "swift" {{{
		self.ctx.stroke()
	}}}
}

func beginPath override
{
	lang "swift" {{{
		self.ctx.beginPath()
	}}}
}

func moveTo(x as double, y as double) override
{
	lang "swift" {{{
		self.ctx.move(to: CGPoint(x: x, y: y))
	}}}
}

func closePath override
{
	lang "swift" {{{
		self.ctx.closePath()
	}}}
}

func lineTo(x as double, y as double) override
{
	lang "swift" {{{
		self.ctx.addLine(to: CGPoint(x: x, y: y))
	}}}
}

func clip override
{
	lang "swift" {{{
		self.ctx.clipTo(to: CGRect(rectangle))
	}}}
}

func quadraticCurveTo(cpx as double, cpy as double, x as double, y as double) override
{
	lang "swift" {{{
		var to = CGPoint(x: cpx, y: cpy)
		var cp = CGPoint(x: x, y: y)
		self.ctx.addQuadCurve(to: to, control: cp)
	}}}
}

func bezierCurveTo(cp1x as double, cp1y as double, cp2x as double, cp2y as double, x as double, y as double) override
{
	lang "swift" {{{
		var to = CGPoint(x: x, y: y)
		var cp1 = CGPoint(x: cp1x, y: cp1y)
		var cp2 = CGPoint(x: cp2x, y: cp2y)
		self.ctx.addCurveTo(to: to, control1: cp1, control2: cp2)
	}}}
}

func arc(x as double, y as double, r as double, sAngle as double, eAngle as double, counterclockwise as bool) override
{
	lang "swift" {{{
		var point = CGPoint(x: x, y: y)
		var rr = r as float
		var sa = Math.toRadians(sAngle) as float
		var ea = Math.toRadians(eAngle) as float
		self.ctx.addArc(center: point, radius: rr, startAngle: sa, endAngle: ea, clockwise: counterclockwise)
	}}}
}

func arcTo(x1 as double, y1 as double, x2 as double, y2 as double, r as double)
{
	lang "swift" {{{
		self.ctx.addArc(tangent1End: CGPoint(x: x1, y: y1), tangent2End: CGPoint(x: x1, y: y1), radius: r as float)
	}}}
}

func isPointInPath(x as double, y as double) override as bool
{
	lang "swift" {{{
		self.ctx.currentPointOfPath = CGPoint(x: x, y: y)
	}}}
}

func scale(scalewidth as double, scaleheight as double) override
{
	lang "swift" {{{
		self.ctx.scaleBy(scalewidth as float, scaleheight as float)
	}}}
}

func rotate(angle as double) override
{
	lang "swift" {{{
		self.ctx.rotate(angle as float)
	}}}
}

func translate(x as double, y as double) override
{
	lang "swift" {{{
		self.ctx.translateBy(x as float, y as float)
	}}}
}

func transform(a as double, b as double, c as double, d as double, e as double, f as double) stub override
{
	var aa = a as float
	var bb = b as float
	var cc = c as float
	var dd = d as float
	var ee = e as float
	var ff = f as float
	lang "swift" {{{
		self.ctx.concatenate(_: CGAffineTransform(a: aa, b: bb, c: cc, d: dd, e: ee, f: ff))
	}}}
}

func setTransform(a as double, b as double, c as double, d as double, e as double, f as double) stub override

func setFont(font as FontDescription) override:
	fontDescription = font

func setTextAlign(align as int) override:
	textAlign = align

func setTextBaseline(baseline as int) override:
	textBaseline = baseline

func fillText(text as string, x as double, y as double, maxWidth as double) stub override

func strokeText(text as string, x as double, y as double, maxWidth as double) override
{
	lang "swift" {{{
		let paragraphStyle = NSMutableParagraphStyle()
		paragraphStyle.alignment = .center
		let attributes: [NSAttributedString.Key : Any] = [
			.paragraphStyle: paragraphStyle,
			.font: UIFont.systemFont(ofSize: 12.0),
			.foregroundColor: UIColor.blue
		]
		let attributedString = NSAttributedString(string: text, attributes: attributes)
		let stringRect = CGRect(x, y, maxWidth)
		attributedString.draw(in: stringRect)
	}}}
}

func measureTextHeight(text as string) stub override as double
func measureTextWidth(text as string) stub override as double

func drawImage(img as Image, x as double, y as double) override
{
	var aimage = assert img as ImageForSwift
	var simg = assert aimage.getSwiftImage()
	lang "swift" {{{
		simg.draw(at: CGPoint(x: x, y: y))
		UIGraphicsEndImageContext()
	}}}
}

func drawAndScaleImage(img as Image, x as double, y as double, width as double, height as double) override
{
	lang "swift" {{{
		let rect = CGRect(x: x, y: y, width: width, height: height)
		let image = img as! UIImage
		image.draw(in: rect)
		self.ctx.addRect(rect)
		UIGraphicsEndImageContext()
	}}}
}

func drawAndProcessImage(img as Image, sx as double, sy as double, swidth as double, sheight as double, x as double, y as double, width as double, height as double) override
{
	assert img
	var scaled = assert img.scaleToSize(width as int, height as int)
	var aimage = assert scaled as! ImageForSwift
	var image = assert aimage.getSwiftImage()
	lang "swift" {{{
		image.draw(in: CGRect(x: sx, y: sy, width: swidth, height: sheight))
		UIGraphicsEndImageContext()
	}}}
}

func setGlobalAlpha(alpha as double) override
{
	lang "swift" {{{
		self.ctx.setAlpha(alpha)
	}}}
	
}

func save override
{
	lang "swift" {{{
		self.ctx.saveGState()
	}}}
}

func restore override
{
	lang "swift" {{{
		self.ctx.restoreGState()
	}}}
}

func createDefaultStrokeStyle as !"NSAttributedString.Key"
{
	return lang "swift" {{{ strokeTextAttributes = [
		NSAttributedString.Key.strokeColor : Color.black(),
		NSAttributedString.Key.foregroundColor : Color.white(),
		NSAttributedString.Key.strokeWidth : lineWidth as float,
		NSAttributedString.Key.font : fontDescription
	] as [NSAttributedString.Key : Any]
	}}}
}
