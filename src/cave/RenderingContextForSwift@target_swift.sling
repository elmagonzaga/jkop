
/*
 * This file is part of Jkop
 * Copyright (c) 2016-2018 Job and Esther Technologies Oy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class is RenderingContext:

func forCanvas(context as GuiApplicationContext, canvas as !"UIView") static as this
{
	var v = new this()
	v.setCanvas(canvas)
	v.setContext(context)
	return v
}

prop context as GuiApplicationContext
prop canvas as !"UIView"
var rectObject as !"CGRect"
var fontDescription as FontDescription
var textAlign = RenderingContext.ALIGN_LEFT
var lineWidth = 5
var fillPaint as Color

func setFillStyle(style as object) override
{
	var f as Color
	if style is string {
		f = Color.instance(style as! string)
	}
	else if style is Color {
		f = style as! Color
	}
	if f {
		let ctx = UIGraphicsGetCurrentContext()
		ctx.fill(rectObject)
		let color: UIColor = f.toARGBInt32()
		color.set()
	}
}

func setStrokeStyle(style as object) override
{
	var f as Color
	if style is string {
		f = Color.instance(style as! string)
	}
	else if style is Color {
		f = style as! Color
	}
	if f {
		let ctx = UIGraphicsGetCurrentContext()
		ctx.stroke(rectObject)
		let color: UIColor = f.toARGBInt32()
		color.set()
	}
}

func setShadowColor(color as Color) stub override
func setShadowBlur(blur as double) stub override
func setShadowOffsetX(offset as double) stub override
func setShadowOffsetY(offset as double) stub override
func createLinearGradient(x0 as double, y0 as double, x1 as double, y1 as double) stub override as object
func createPattern(image as Image, repeat as int) override as object

func createRadialGradient(x0 as double, y0 as double, r0 as double, x1 as double, y1 as double, r1 as double) override as object
{
	var centerX = x0 + r0 as float
	var centerY = y0 + r0 as float
	var radius0 = r0 as float
	var radius1 = r1 as float
	lang "swift" {{{
		var gradient = NSGradient(Color.black, Color.white())
		gradient.draw(centerX, radius0, centerY, radius1, drawsAfterEndingLocation: NSGradient.DrawingOptions)
	}}}
}

func addColorStop(gradient as object, index as double, color as Color) stub override

func setLineCap(cap as int) override
{
	var c as int
	lang "swift" {{{
		if cap == RenderingContext.LINE_CAP_BUTT {
			c = CGLineCap.butt
		}
		if cap == RenderingContext.LINE_CAP_ROUND {
			c = CGLineCap.round
		}
		if cap == RenderingContext.LINE_CAP_SQUARE {
			c = CGLineCap.square
		}
		var ctx = UIGraphicsGetCurrentContext
		ctx.setLineCap(_: c)
	}}}
}

func setLineJoin(join as int) override
{
	var jn as int
	lang "swift" {{{
		if join == RenderingContext.LINE_JOIN_MITER {
			jn = CGLineJoin.miter
		}
		if join == RenderingContext.LINE_JOIN_BEVEL {
			jn = CGLineJoin.bevel
		}
		if join == RenderingContext.LINE_JOIN_ROUND {
			jn = CGLineJoin.round
		}
		var ctx = UIGraphicsGetCurrentContext
		ctx.setLineJoin(_: jn)
	}}}
}

func setLineWidth(width as double) override
{
	lineWidth = width as float
	lang "swift" {{{
		var ctx = UIGraphicsGetCurrentContext
		ctx.setLineWidth(lineWidth)
	}}}
}

func setMiterLimit(limit as double) override
{
	lang "swift" {{{
		var ctx = UIGraphicsGetCurrentContext
		ctx.setMiterLimit(limit as float)
	}}}
}

func rect(x as double, y as double, width as double, height as double) override
{
	var xx = x as int
	var yy = y as int
	var ww = xx + width as int
	var hh = yy + height as int
	lang "swift" {{{
		rectObject = CGRect(xx, yy, ww, hh)
	}}}
}

func fillRect(x as double, y as double, width as double, height as double) override
{
	// FIXME
	assert canvas
	var xx = x as float
	var yy = y as float
	var ww = xx + width as float
	var hh = yy + height as float
	lang "swift" {{{
		let cgRect = CGRect(xx, yy, ww, hh)
		var ctx = UIGraphicsGetCurrentContext
		ctx.fill(_ rect: cgRect)
		canvas.draw(cgRect)
	}}}
}

func strokeRect(x as double, y as double, width as double, height as double) override
{
	//FIXME
	assert canvas
	var xx = x as float
	var yy = y as float
	var ww = xx + width as float
	var hh = yy + height as float
	lang "swift" {{{
		let rect = CGRect(x: xx, y: yy, width: ww, height: hh)
		canvas.draw(rect)
	}}}
}

func clearRect(x as double, y as double, width as double, height as double) override
{
	lang "swift" {{{
		let rect = CGRect(x: x, y: y, width: width, height: height)
		var ctx = UIGraphicsGetCurrentContext
		ctx.clearRect(rect)
	}}}
}

func fill override
{
	lang "swift" {{{
		let ctx = UIGraphicsGetCurrentContext()
		ctx.fill(_ rect: rectObject)
	}}}
	
}

func stroke override
{
	lang "swift" {{{
		let ctx = UIGraphicsGetCurrentContext()
		ctx.stroke()
	}}}
}

func beginPath override
{
	lang "swift" {{{
		let ctx = UIGraphicsGetCurrentContext()
		ctx.beginPath()
	}}}
}

func moveTo(x as double, y as double) override
{
	lang "swift" {{{
		let ctx = UIGraphicsGetCurrentContext()
		ctx.move(to: CGPoint(x, y))
	}}}
}

func closePath override
{
	lang "swift" {{{
		let ctx = UIGraphicsGetCurrentContext()
		ctx.closePath()
	}}}
}

func lineTo(x as double, y as double) override
{
	lang "swift" {{{
		let ctx = UIGraphicsGetCurrentContext()
		ctx.addLine(to: CGPoint(x, y))
	}}}
}

func clip override
{
	lang "swift" {{{
		let ctx = UIGraphicsGetCurrentContext()
		ctx.clipTo(to: CGRect(rectObject))
	}}}
}

func quadraticCurveTo(cpx as double, cpy as double, x as double, y as double) override
{
	lang "swift" {{{
		var to = CGPoint(cpx, cpy)
		var cp = CGPoint(x, y)
		let ctx = UIGraphicsGetCurrentContext()
		ctx.addQuadCurve(to: CGPoint(to), control: CGPoint(cp))
	}}}
}

func bezierCurveTo(cp1x as double, cp1y as double, cp2x as double, cp2y as double, x as double, y as double) override
{
	lang "swift" {{{
		var to = CGPoint(x, y)
		var cp1 = CGPoint(cp1x, cp1y)
		var cp2 = CGPoint(cp2x, cp2y)
		let ctx = UIGraphicsGetCurrentContext()
		ctx.addCurveTo(to: CGPoint(to), control1: CGPoint(cp1), control2(CGPoint(cp2)))
	}}}
}

func arc(x as double, y as double, r as double, sAngle as double, eAngle as double, counterclockwise as bool) override
{
	lang "swift" {{{
		var point = CGPoint(x, y)
		var rr = r as float
		var sa = Math.toRadians(sAngle) as float
		var ea = Math.toRadians(eAngle) as float
		let ctx = UIGraphicsGetCurrentContext()
		ctx.addArc(center: point, radius: rr, startAngle: sa, endAngle: ea, clockwise: counterclockwise)
	}}}
}

func arcTo(x1 as double, y1 as double, x2 as double, y2 as double, r as double)
{
	var ctx = UIGraphicsGetCurrentContext()
	ctx.addArc(tangent1End: CGPoint(x1, y1), tangent2End: CGPoint(x1, y1), radius: r as float)
}

func isPointInPath(x as double, y as double) override as bool

func scale(scalewidth as double, scaleheight as double) override
{
	let ctx = UIGraphicsGetCurrentContext()
	ctx.scaleBy(scalewidth as float, scaleheight as float)
}

func rotate(angle as double) override
{
	let ctx = UIGraphicsGetCurrentContext()
	ctx.rotate(angle as float)
}

func translate(x as double, y as double) override
{
	let ctx = UIGraphicsGetCurrentContext()
	ctx.translateBy(x as float, y as float)
}

func transform(a as double, b as double, c as double, d as double, e as double, f as double) stub override
func setTransform(a as double, b as double, c as double, d as double, e as double, f as double) override

func setFont(font as FontDescription) override:
	fontDescription = font

func setTextAlign(align as int) override:
	textAlign = align

func setTextBaseline(baseline as int) stub override
func fillText(text as string, x as double, y as double, maxWidth as double) stub override

func strokeText(text as string, x as double, y as double, maxWidth as double) override
{
	let paragraphStyle = NSMutableParagraphStyle()
	paragraphStyle.alignment = .center
	let attributes: [NSAttributedString.Key : Any] = [
		.paragraphStyle: paragraphStyle,
		.font: UIFont.systemFont(ofSize: 12.0),
		.foregroundColor: UIColor.blue
	]
	let attributedString = NSAttributedString(string: text, attributes: attributes)
	let stringRect = CGRect(x, y, maxWidth)
	attributedString.draw(in: stringRect)
}

func measureTextHeight(text as string) stub override as double
func measureTextWidth(text as string) stub override as double

func drawImage(img as Image, x as double, y as double) override
{
	//FIXME
	assert canvas
	var aimage = assert img as ImageForSwift
	var simg = assert aimage.getSwiftImage()
	var point = CGPoint(x, y)
	simg.draw(point)
}

func drawAndScaleImage(img as Image, x as double, y as double, width as double, height as double) override
{
	let ctx = UIGraphicsGetCurrentContext()
	let rect = CGRect(x: x, y: y, width: width, height: height)
	CGContextAddRect(ctx, rect)
	ctx.draw(img, rect)
}

func drawAndProcessImage(img as Image, sx as double, sy as double, swidth as double, sheight as double, x as double, y as double, width as double, height as double) override
{
	assert img
	var scaled = assert img.scaleToSize(width as int, height as int)
	var aimage = assert scaled as ImageForSwift
	var bitmap = assert aimage.getSwiftImage()
	let ctx = UIGraphicsGetCurrentContext()
	ctx.draw(img, CGRect(x: sx, y: sy, width: swidth, height: sheight))
}

func setGlobalAlpha(alpha as double) override
{
	let ctx = UIGraphicsGetCurrentContext()
	ctx.setAlpha(alpha as double)
}

func save override
{
	let ctx = UIGraphicsGetCurrentContext()
	ctx.saveGState()
}
func restore override
{
	let ctx = UIGraphicsGetCurrentContext()
	ctx.restoreGState()
}
